\chapter{Evaluation} \label{chap:evaluation}

\section{Data} \label{sec:data}

The data consists of many sequences of unsigned integers known as \textit{reads}. Each integer represents the quantised ionic current recorded at a certain time step as a single-stranded DNA or RNA molecule is driven through a nanoscale protein pore (or \textit{nanopore}) \cite{Wang2021}. Disturbances in the ionic current caused by the molecule's biological structure can be used to determine its nucleic acid sequence.

Let each read be represented by
\[ x := (x_i\mid x_i \in \mathbb{Z} \cap [0, 2^{16})) \]
where $i\in \mathbb{Z}\cap [0, n)$. Computationally, $x$ is an unsigned 16-bit integer array with $n$ elements. However, in practice the full range of $2^{16}$ integers is never met.

\subsection{Characteristics}

%TODO discuss statistics of nanopore data
%plot some nanopore signals
%talk about stall, homopolymer, regular dna sections

\subsection{Methods}

% Explore integer methods without generic

Instead, each integer can be represented more space-efficiently by using $b<16$ bits where \[b(x)=\lceil\log_2(\max(x))\rceil.\] In this case, the compression ratio would be approximately $16/b$:
\begin{align*}
	\text{Compression Ratio} &= \frac{\text{Uncompressed Bytes}}{\text{Compressed Bytes}}\\
	&=\frac{\frac{16}{8}n}{\lceil\frac{b}{8}n\rceil}\\
	&\stackrel{n\to\infty}{\longrightarrow}\frac{16}{b}.
\end{align*}
A better strategy would be to initially transform the data such that its range is decreased.
%Let \[T=\{t\mid t:X\to Y\}\] be the set of bijections from $X$, the set of reads, to $Y := \{(y_i\mid y_i\in \mathbb{N}_0)\}$. One such transformation is defined by
Let \[T=\{t\mid t:X\to X\}\] be the set of functions from $X$, the set of reads, to itself. One such transformation subtracts the minimum of $x$ from each integer and is defined by \[ submin(x) := (x_i-\min(x)). \] Each transformed integer can then be represented using fewer than or the same number of bits:
%A better strategy would be to first transform $x$ by subtracting the minimum of $x$ from each integer. That is, $x\mapsto(x_i-\min(x))$. Then,
\begin{align*}
	b(submin(x))&=\lceil\log_2(\max(submin(x)))\rceil\\
	&=\lceil\log_2(\max(x-\min(x)))\rceil\\
	&=\lceil\log_2(\max(x)-\min(x))\rceil\\
	&\le b(x)
\end{align*}
since $\log$ is an increasing function.
%However, in practice each integer lies within $[2^7,2^{11}]$. This means each integer can be represented using 11 bits rather than 16. If each integer is stored using $b$ bits, the compression ratio would be approximately $16/b$ as follows:
%Hence, using 11 bits per integer results in a compression ratio of approximately $1.\overline{45}$. Note that the optimal $b$ is given by
Another transformation takes the differences between successive signals and is defined by
\[ \delta(x):=(x_{i+1}-x_i\mid 0\le i\le n-2).\]
% TODO analyse delta

\subsection{Subsequence Searching}
Some of the previously discussed compression methods, such as bit packing and FOR, depend on global statistics of the data such as the minimum and maximum.
For nanopore signal data, these statistics are easily dominated by outliers in the data.
One naive solution is to separately compress adjacent subsequences of equal length.
This approach has previously been successful in the literature with methods such as SIMD-BP128 and fast patched frame-of-reference (FastPFOR) performing compression in blocks of 128 integers \cite{lemire-simd}.

% Explore blocks of different sizes
% Explore blocks of different equal splits

Consider partitioning the nanopore signal into adjacent variable length blocks.
Let $P(x,s)$ be the partitioning of signal $x$ into $|s|=m\ge 1$ partitions according to partitioner $s$ where
\[ s := (s_j \in \mathbb{Z}\cap [0, n) \mid s_0 = 0)\]
and $s_j$ is the starting index of the $j$-th partition such that
\[ P(x,s) = (p_j) := ((x_{s_j},x_{s_j+1},\dots,x_{s_{j+1}-1}))_{j\in\mathbb{Z}\cap[0,m)}.\]
% TODO this is not correct for the last partition
%((x_{s_0},x_{s_0+1},\dots,x_{s_1-1}),(x_{s_1},\dots,x_{s_2-1}),\dots,(x_{s_{m-1}},\dots,x_n)) .\]
For example, if $x=(656,527,515,527,526)$ and $s = (0,3,4)$ then $m=3$ and
\[P(x,s)=((656,527,515),(527),(526)).\]

Given the partitioning $P$ we would like to compress each partition $p_j$ separately and concatenate the results.
Let $M(p)$ be the compressed bytes of partition $p$ after applying compression method $M$.
Then, the compressed bytes of signal $x$ under partitioner $s$ is the concatenation of the compressed bytes of each partition $M(p_j)$ given by
\[ C(x,s,M) := (M(p_j)\mid p_j=P(x,s)_j). \]
Let $\hat s$ be the partitioner of $x$ which minimises the number of compressed bytes
\[ |C(x,\hat s,M)| = \min_s |C(x,s,M)| = \min_s \sum_j|M(p_j)|. \]
The minimum number of compressed bytes can be found using the following recursive relationship
\[ |C(x,\hat s,M)| = \min\{M(x),\min_{0\le k\le n-2}\{|C(x_L,\hat s_{x_L},M)| + |C(x_R,\hat s_{x_R},M)|\}\} \]
where $x_L=(x_0,x_1,\dots,x_k)$ and $x_R=(x_{k+1},\dots,x_{n-1})$.
That is, the compressed bytes with minimum length are found by either compressing the whole signal as usual or by dividing the signal into two partitions and concatenating each partition's minimum length compressed bytes.

For a signal of size $n$, the number of comparisons is given by the recurrence relation
\begin{align*}
	c_1 &= c_{M,1}\\
	c_n &= c_{M,n} + 1 + \sum_{0\le k\le n-2}(c_{k+1}+c_{n-k-1} + 1) &n\ge 2
\end{align*}
where $c_{M,n}$ is the number of comparisons for the compression method $M$ on input size $n$.
This can be simplified as follows
\begin{align*}
	c_n &= c_{M,n} + 1 + \sum_{1\le k\le n-1}(2c_k + 1)\\
	&= c_{M,n} + 1 + \frac{n(n-1)}{2} + 2\sum_{1\le k\le n-1}c_k &n\ge 2
\end{align*}
Let's write $c_n$ in terms of $c_{n-1}$ in order to solve the recurrence more easily.
\begin{align*}
	c_{n-1} &= c_{M,n-1} + 1 + \frac{(n-1)(n-2)}{2} + 2\sum_{1\le k\le n-2}c_k & n\ge 3\\
	c_{n} - c_{n-1} &= c_{M,n} - c_{M,n-1} + \frac{n(n-1)}{2} - \frac{(n-1)(n-2)}{2} + 2c_{n-1}\\
	c_{n} &= c_{M,n} - c_{M,n-1} + n-1 + 3c_{n-1} & n\ge 3\\
	c_2 &= c_{M,2}+2c_{M,1}+2\\
	c_1 &= c_{M,1}
\end{align*}
Unrolling this we find that
\[ c_n = c_{M,n} + 2\sum_{1\le k\le n-1}3^{k-1}c_{M,n-k}+2\times 3^{n-2}+\sum_{1\le k\le n-2}3^{k-1}(n-k). \]
The can be separated into two parts, the compression computations
\[ \phi_n = c_{M,n} + 2\sum_{1\le k\le n-1}3^{k-1}c_{M,n-k}\]
and the number of comparisons
\[ \xi_n = 2\times 3^{n-2}+\sum_{1\le k\le n-2}3^{k-1}(n-k). \]
If the compression method has linear time complexity (i.e. $c_{M,n} = O(n)$) then
\begin{align*}
	\phi_n &= O(n) + 2\sum_{1\le k\le n-1}3^{k-1}O(n-k)\\
	%TODO don't know if this is correct or not
	&= O(n) - O(n-1) + \frac{3^{n}}{2} - \frac{3}{2} & \text{See Appendix \ref{app:phi}}\\
	&= O(3^n).
\end{align*}
That is, the compression computations take exponential time. For the number of comparisons
\begin{align*}
	\xi_n &= 2\times 3^{n-2}+\frac{5}{4}\times 3^{n-2}-\frac{2n+1}{4}\\
	&= \frac{13\times 3^{n-2}-2n-1}{4} &\text{See Appendix \ref{app:xi}}\\
	&=O(3^n).
\end{align*}
It also takes exponential time for the number of comparisons, hence $c_n=O(3^n)$.

However, this algorithm re-computes the compressed bytes of subsequences many times rather than calculating it once and caching the data.
A better approach is to use a bottom-up dynamic programming which avoids recursion and hence stack overflows.
The approach would first compute all $|C(y,\hat s,M)|$ where $y$ has length 1, storing the result in a triangular matrix $D\in \mathbb{Z}$

However, we can exploit the characteristics of nanopore signal data to find better subsequences.
For example, each read typically consists of a stall.

%The next idea is to divide $x$ into subsequences with small range and compress each subsequence separately.
%Let $OPT(i, j)$ be the minimum number of bytes after compressing $(x_i,\dots, x_j)$. Then,
%\[ OPT(i, j) = \min(bytes(i, j),\min_{i\le k<j}(OPT(i, k) + OPT(k+1, j))) \]
